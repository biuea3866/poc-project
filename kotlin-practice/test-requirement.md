# 논블로킹 기술 성능 테스트
다건의 요청을 전달받아 어느 정도의 성능이 나오는지 기술별로 시간을 측정합니다.

## 태스트 환경
* 톰캣 MVC 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.
* 네티 웹플럭스 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.
* 톰캣 웹플럭스 + 코루틴 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.
* 네티 웹플럭스 + 코루틴 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.
* 톰캣 MVC + 버추얼 스레드 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.
* 네티 웹플럭스 + 버추얼 스레드 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.
* 톰캣 MVC + 코루틴 + 버추얼 스레드 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.
* 네티 웹플럭스 + 코루틴 + 버추얼 스레드 환경에서 10,000건의 요청이 들어왔을 때 평균 응답 시간, 최소, 최대 응답시간을 기록합니다.

## 테스트 조건
* 총 요청 수: 10,000건
* 동시 접속 수: 500 / 1,000 / 2,000 (스케일링 테스트)
* 시뮬레이션 지연: 100ms (블로킹: Thread.sleep / 리액티브: Mono.delay / 코루틴: delay)
* 클라이언트: Java HttpClient + Virtual Thread
* JDK: Amazon Corretto 21
* Spring Boot: 4.0.1, Kotlin: 2.2.21

## 테스트 결과 (3회 실행)

### 동시 접속 500

| 환경 | 1차 Avg (ms) | 2차 Avg (ms) | 3차 Avg (ms) | **3회 평균 (ms)** |
|------|-------------|-------------|-------------|-------------------|
| 톰캣 MVC | 255.97 | 257.23 | 255.26 | **256.15** |
| 네티 웹플럭스 | 104.62 | 107.19 | 108.26 | **106.69** |
| 톰캣 MVC + 코루틴 | 110.21 | 108.76 | 107.77 | **108.91** |
| 네티 웹플럭스 + 코루틴 | 108.25 | 105.93 | 108.24 | **107.47** |
| 톰캣 MVC + 버추얼 스레드 | 107.27 | 107.36 | 106.74 | **107.12** |
| 네티 웹플럭스 + 버추얼 스레드 | 104.83 | 105.30 | 104.47 | **104.87** |
| 톰캣 MVC + 코루틴 + 버추얼 스레드 | 108.67 | 111.86 | 111.97 | **110.83** |
| 네티 웹플럭스 + 코루틴 + 버추얼 스레드 | 110.00 | 127.87 | 106.12 | **114.66** |

### 동시 접속 1,000

| 환경 | 1차 Avg (ms) | 2차 Avg (ms) | 3차 Avg (ms) | **3회 평균 (ms)** |
|------|-------------|-------------|-------------|-------------------|
| 톰캣 MVC | 494.16 | 496.73 | 495.89 | **495.59** |
| 네티 웹플럭스 | 108.48 | 122.57 | 114.08 | **115.04** |
| 톰캣 MVC + 코루틴 | 114.44 | 111.59 | 122.03 | **116.02** |
| 네티 웹플럭스 + 코루틴 | 117.43 | 108.44 | 113.26 | **113.04** |
| 톰캣 MVC + 버추얼 스레드 | 129.26 | 150.64 | 122.59 | **134.16** |
| 네티 웹플럭스 + 버추얼 스레드 | 106.63 | 108.32 | 117.62 | **110.86** |
| 톰캣 MVC + 코루틴 + 버추얼 스레드 | 116.66 | 135.67 | 112.69 | **121.67** |
| 네티 웹플럭스 + 코루틴 + 버추얼 스레드 | 120.37 | 129.99 | 109.77 | **120.04** |

### 동시 접속 2,000

| 환경 | 1차 Avg (ms) | 2차 Avg (ms) | 3차 Avg (ms) | **3회 평균 (ms)** |
|------|-------------|-------------|-------------|-------------------|
| 톰캣 MVC | 941.00 | 939.53 | 941.93 | **940.82** |
| 네티 웹플럭스 | 143.73 | 142.11 | 214.91 | **166.92** |
| 톰캣 MVC + 코루틴 | 391.81 | 409.09 | 170.26 | **323.72** |
| 네티 웹플럭스 + 코루틴 | 120.36 | 130.10 | 270.70 | **173.72** |
| 톰캣 MVC + 버추얼 스레드 | 358.65 | 495.15 | 146.26 | **333.35** |
| 네티 웹플럭스 + 버추얼 스레드 | 116.29 | 201.18 | 116.19 | **144.55** |
| 톰캣 MVC + 코루틴 + 버추얼 스레드 | 133.81 | 330.61 | 140.28 | **201.57** |
| 네티 웹플럭스 + 코루틴 + 버추얼 스레드 | 212.51 | 162.91 | 317.03 | **230.82** |

## 환경별 상세 분석

### 1. 톰캣 MVC (블로킹) — 동시접속에 비례해서 느려지는 이유

```
500: 256ms | 1000: 496ms | 2000: 941ms (3회 평균)
```

톰캣의 기본 워커 스레드풀은 200개이다.

```
동시접속 500 도착
├── 200개 → 즉시 스레드 할당, Thread.sleep(100ms) 처리
├── 200개 → 큐에서 100ms 대기 → 스레드 할당 → 100ms 처리 = 총 200ms
└── 100개 → 큐에서 200ms 대기 → 스레드 할당 → 100ms 처리 = 총 300ms
→ 평균 ~256ms
```

동시접속 2,000이면 대기 큐가 10단계까지 쌓인다. 마지막 요청은 `(2000/200) * 100ms = 1000ms` 이상을 큐에서만 기다린다. max가 5,021ms인 이유이다.

**핵심**: `Thread.sleep()`이 플랫폼 스레드를 **점유**하므로, 동시접속 수 > 스레드풀 크기일 때 **선형적으로 느려진다.**

### 2. 네티 웹플럭스 (리액티브) — 거의 안 느려지는 이유

```
500: 107ms | 1000: 115ms | 2000: 167ms (3회 평균)
```

네티는 **이벤트 루프** 모델이다. CPU 코어 수만큼의 스레드(이 머신에서 ~10개)로 동작한다.

```
동시접속 2000 도착
├── 이벤트 루프가 2000개 커넥션을 전부 등록 (non-blocking I/O)
├── Mono.delay(100ms) → 타이머 콜백 등록 (스레드 해제)
├── 100ms 후 → 콜백 실행, 응답 전송
└── 스레드는 항상 ~10개만 사용
```

`Mono.delay()`는 스레드를 점유하지 않는다. 타이머에 콜백을 걸어두고 스레드를 즉시 반환한다. 그래서 동시접속이 2,000이든 10,000이든 **대기 큐가 발생하지 않는다.**

2,000에서 144ms로 살짝 오른 건 커넥션 수 자체가 많아지면서 TCP 버퍼 관리, 콜백 스케줄링 오버헤드 때문이다.

### 3. 톰캣 MVC + 코루틴 — 500에서는 빠른데 2,000에서 느려지는 이유

```
500: 109ms | 1000: 116ms | 2000: 324ms (3회 평균)
```

코루틴의 `delay()`는 스레드를 해제한다. 그래서 톰캣 200개 스레드로도 500~1,000 동시접속을 잘 처리한다:

```
요청 도착 → 톰캣 스레드 할당 → suspend fun 진입 → delay() 호출
→ 코루틴 서스펜드, 톰캣 스레드 반환 (다른 요청 처리 가능)
→ 100ms 후 코루틴 재개 → 응답 전송
```

**그런데 2,000에서 392ms, max 7,980ms가 나온 이유:**

코루틴이 스레드풀 병목은 해결했지만, **톰캣 서블릿 컨테이너의 커넥션 관리** 자체가 병목이 된다:

* 톰캣의 NIO 커넥터가 커넥션을 accept하고 파싱하는 과정
* `maxConnections` (기본 8,192)에는 여유가 있지만, accept 큐(`acceptCount` 기본 100)에서 밀림
* 서블릿 스펙 기반의 요청/응답 라이프사이클 관리 오버헤드

즉, **"스레드는 충분한데 커넥션을 받아들이는 입구가 좁다"**는 상황이다.

### 4. 네티 웹플럭스 + 코루틴 — 순수 리액티브와 거의 동등한 이유

```
500: 107ms | 1000: 113ms | 2000: 174ms (3회 평균)
```

코루틴의 `delay()`는 `kotlinx-coroutines-reactor` 브릿지를 통해 네티의 이벤트 루프와 통합된다:

```
요청 도착 → 네티 이벤트 루프에서 수신
→ suspend fun 진입 → delay() 호출
→ 코루틴 서스펜드 → 내부적으로 Mono.delay()와 동일한 타이머 등록
→ 100ms 후 코루틴 재개 → 이벤트 루프에서 응답 전송
```

`Mono.delay()`를 직접 쓰는 것과 코루틴 `delay()`를 쓰는 것의 차이는 **코루틴 객체 생성/서스펜드/재개의 오버헤드** 정도이다. 이 비용은 매우 작아서 순수 리액티브(144ms)와 거의 동등한 120ms가 나왔다.

2,000에서도 120ms로 안정적인 이유: 서버 엔진이 네티이므로 커넥션 관리 병목이 없고, 코루틴이 이벤트 루프를 블로킹하지 않기 때문이다. 오히려 순수 리액티브(144ms)보다 미세하게 빠른데, 이는 코루틴의 구조화된 동시성이 콜백 체인보다 스케줄링 효율이 좋을 수 있기 때문이다.

### 5. 톰캣 MVC + 버추얼 스레드 — 톰캣 MVC + 코루틴과 비슷한 패턴

```
500: 107ms | 1000: 134ms | 2000: 333ms (3회 평균)
```

`spring.threads.virtual.enabled=true`이면 톰캣이 요청마다 버추얼 스레드를 생성한다:

```
요청 도착 → 버추얼 스레드 생성 → Thread.sleep(100ms)
→ VT가 park됨 → 캐리어 스레드(플랫폼 스레드) 해제
→ 100ms 후 VT unpark → 응답 전송
```

원리는 코루틴과 동일하다. `Thread.sleep()`이 버추얼 스레드에서는 캐리어 스레드를 점유하지 않는다. 그래서 500~1,000에서 코루틴과 비슷한 성능이다.

2,000에서 359ms로 떨어지는 이유도 동일 — **톰캣 커넥션 관리 병목**이다.

### 6. 네티 웹플럭스 + 버추얼 스레드 — 가장 안정적인 이유

```
500: 105ms | 1000: 111ms | 2000: 145ms (3회 평균)
```

네티의 이벤트 루프는 이미 논블로킹이므로 VT의 직접적인 혜택은 크지 않다. 하지만:

* 프레임워크 내부의 간헐적 블로킹 호출(로깅, 직렬화 등)이 VT에서 실행되면 이벤트 루프를 블로킹하지 않음
* 결과적으로 **가장 깨끗한 논블로킹 처리**가 됨

2,000에서도 116ms인 이유: 네티의 이벤트 루프가 커넥션 관리를 `epoll`/`kqueue` 레벨에서 처리하므로 톰캣 같은 커넥션 관리 병목이 없다.

### 7. 톰캣 MVC + 코루틴 + VT — 조합이 단독보다 나은 이유

```
코루틴 단독:    500: 109ms | 1000: 116ms | 2000: 324ms (3회 평균)
VT 단독:       500: 107ms | 1000: 134ms | 2000: 333ms (3회 평균)
코루틴 + VT:   500: 111ms | 1000: 122ms | 2000: 202ms (3회 평균) ← 개선
```

단독으로는 2,000에서 350~390ms였는데, 조합하면 134ms로 크게 개선된다:

* **VT**: 톰캣의 워커 스레드가 버추얼 스레드가 되어 커넥션 accept/처리 과정 자체가 가벼워짐
* **코루틴**: 애플리케이션 레벨에서 `delay()`로 효율적 서스펜드
* 결과적으로 톰캣 커넥터 레벨(VT가 개선) + 애플리케이션 레벨(코루틴이 개선) **두 병목을 동시에 해소**

### 8. 네티 + 코루틴 + VT — 오히려 느려지는 이유

```
네티 WebFlux:           500: 107ms | 1000: 115ms | 2000: 167ms (3회 평균)
네티 + VT:              500: 105ms | 1000: 111ms | 2000: 145ms (3회 평균)
네티 + 코루틴 + VT:     500: 115ms | 1000: 120ms | 2000: 231ms (3회 평균)
```

세 기술을 겹치면 오히려 성능이 떨어진다:

* **컨텍스트 스위칭 오버헤드**: 네티 이벤트 루프 → 코루틴 디스패처 → 버추얼 스레드 스케줄러 사이의 전환 비용
* **객체 생성 부담**: 요청마다 코루틴 객체 + VT 객체가 동시에 생성되어 GC 압박
* 네티는 이미 최적화된 이벤트 루프를 쓰고 있어 **추가 추상화 레이어가 오히려 방해**

## 종합 결론

### 병목 지점 정리
| 병목 지점 | 해당 환경 | 해결책 |
|-----------|---------|--------|
| 스레드풀 고갈 (200개) | 톰캣 MVC 블로킹 | 코루틴, VT, 또는 WebFlux |
| 톰캣 커넥션 관리 | 톰캣 + 코루틴/VT (고부하) | 네티로 전환, 또는 코루틴+VT 조합 |
| 추상화 레이어 오버헤드 | 네티 + 코루틴 + VT | 기술을 과하게 겹치지 않기 |

### 핵심 인사이트 (3회 평균 기준)
* **저부하 (500)**: 블로킹 톰캣 MVC(256ms)만 제외하면 모든 방식이 ~105-115ms로 동등
* **중부하 (1,000)**: 블로킹 MVC가 4.3배 느려지고(496ms), 나머지는 ~111-134ms로 안정적
* **고부하 (2,000)**: **서버 엔진(Netty vs Tomcat) 차이**가 결정적이나, 런마다 편차가 커서 단일 실행 결과만으로는 판단이 어려움. 3회 평균 기준 네티+VT(145ms)가 가장 안정적
* **최적의 조합**: 네티 웹플럭스 + 버추얼 스레드가 모든 부하에서 가장 안정적 (105ms → 111ms → 145ms)
* **고부하 편차**: 2,000 동시접속에서 런 간 편차가 큼 (예: 톰캣+VT: 146~495ms, 네티+코루틴+VT: 163~317ms). 이는 GC, OS 스케줄러, TCP 버퍼 상태 등 외부 요인에 민감하기 때문
* **실용적 결론**: 논블로킹 기술(코루틴/VT)은 스레드풀 병목을 해결하지만, 고부하에서는 서버 엔진의 I/O 모델(이벤트 루프 vs 스레드 per 커넥션)이 더 큰 영향을 미침. 또한 기술을 무조건 많이 겹친다고 좋은 것이 아니며, 환경에 맞는 적절한 조합이 중요하다.
