# 목표

---
MySQL의 파티셔닝 예제를 적용해보고, 애플리케이션에서 파티셔닝이 올바르게 동작하는지 확인한다.

# 목표 예제

---
## 1. MySQL 데이터 예제
* 2가지 데이터 예제를 생성한다.
* 파티셔닝이 적용되지 않은 상품 데이터 1,000만건
* 파티셔닝이 적용된 상품 데이터 1,000만건
* 파티셔닝이 적용된 상품 데이터의 댓글 2,000만건
* docker-compose를 이용해 MySQL을 구동하고, 데이터 예제 스크립트를 실행한다.

## 2. 애플리케이션 예제
* 상품 데이터 엔티티, 레포지토리를 생성한다.
* 상품 데이터를 조회하는 Controller를 생성한다.
* 상품 데이터와 댓글 데이터를 Join하는 api를 추가한다.
  * 한 API는 파티션 키가 조인에 포함되어있다.
  * 한 API는 파티션 키가 조인에 포함되어 있지 않다.
* 이 Controller ~ Repository는 2가지 데이터 예제 각 한 쌍씩 생성한다.

# 주의 사항

---

* 테스트 사항의 모든 불릿포인트를 유념하며, 적용할 것
* 테스트이기 때문에 간단하게 만들 것
* 결과 값을 기록할 때 보기 편한 테이블 표 형태로 기록할 것

# 테스트 사항

---

* k6를 이용해서 다음의 API 대해 초당 TPS와 Latency를 확인한다.
  * 파티셔닝이 적용되지 않은 상품 데이터 조회 API
  * 파티셔닝이 적용된 상품 데이터 조회 API
  * 파티셔닝이 적용된 상품, 파티셔닝이 적용된 댓글을 JOIN하지만 파티션 키가 포함되지 않은 조회 API
  * 파티셔닝이 적용된 상품, 파티셔닝이 적용된 댓글을 JOIN하지만 파티션 키가 포함된 않은 조회 API
* mysql의 cpu, memory 사용률을 확인한다.
* 그리고 실제로 파티셔닝 프루닝이 되고 있는지 확인한다.
* 이 결과값들을 아라 #결과 섹션에 테이블 표 형태로 기록한다.

# 결과

---

## 성능 테스트 결과 (k6)

### API 성능 비교

| API | 설명 | TPS (req/s) | 평균 Latency | P95 Latency | P90 Latency | 에러율 |
|-----|------|-------------|--------------|-------------|-------------|--------|
| API 1 | 파티셔닝 미적용 상품 조회 | 16.9 | 2.13s | 4.02s | 3.69s | 0% |
| API 2 | 파티셔닝 적용 상품 조회 | 29.3 | 1.18s | 2.16s | 2.00s | 0% |
| API 3 | JOIN 파티션 키 미포함 | 28.3 | 600ms | 1.03s | 950ms | 0% |
| API 4 | JOIN 파티션 키 포함 | 28.0 | 608ms | 1.17s | 1.01s | 0% |

### 주요 발견사항

**1. 파티셔닝 성능 개선**
- API 2 (파티셔닝 적용)가 API 1 (미적용) 대비 **73% 더 높은 TPS** (16.9 → 29.3 req/s)
- P95 Latency가 **46% 감소** (4.02s → 2.16s)
- 평균 Latency가 **45% 감소** (2.13s → 1.18s)

**2. JOIN 쿼리 성능**
- JOIN 쿼리들 (API 3, 4)이 단순 조회 쿼리보다 훨씬 빠름 (avg 604ms vs 1.18s)
  - 이유: 페이지 사이즈가 작음 (10개 vs 100개)
- API 3 (파티션 키 미포함)과 API 4 (파티션 키 포함)의 성능 차이가 거의 없음 (약 1%)
  - 평균 Latency: 600ms vs 608ms
  - P95 Latency: 1.03s vs 1.17s
  - 이유: 데이터가 대부분 2024년에 집중되어 있어 파티션 프루닝 효과가 제한적임

**3. 파티션 프루닝 검증**

파티션 키 포함 쿼리:
```sql
-- 2024년 데이터만 조회하는 쿼리
SELECT * FROM product_partitioned
WHERE created_date BETWEEN '2024-01-01' AND '2024-12-31';

-- 결과: p2024 파티션만 스캔 (파티션 프루닝 적용 ✓)
partitions: p2024
```

파티션 키 미포함 쿼리:
```sql
-- product_id로만 조회하는 쿼리
SELECT * FROM comment WHERE product_id IN (1,2,3);

-- 결과: 모든 파티션 스캔 (p2020,p2021,p2022,p2023,p2024,p_future)
partitions: p2020,p2021,p2022,p2023,p2024,p_future
```

**4. 테스트 환경**
- 데이터: 상품 1,000만건 (파티셔닝 O/X 각각), 댓글 160만건
- 테스트 도구: k6 v1.4.0
- 부하: API 1-2는 50명 동시 사용자, API 3-4는 30명 동시 사용자
- 테스트 시간: 각 2분 (30초 ramp-up + 60초 steady + 30초 ramp-down)

## 결론

1. **파티셔닝의 효과**: RANGE 파티셔닝을 적용하면 날짜 범위 조회 시 **성능이 크게 향상됨** (73% TPS 증가, 45% Latency 감소)

2. **파티션 프루닝 확인**: 파티션 키를 WHERE 절에 포함하면 MySQL이 자동으로 관련 파티션만 스캔함
   - 파티션 키 포함: p2024 단일 파티션만 스캔
   - 파티션 키 미포함: 모든 파티션(p2020~p_future) 스캔

3. **JOIN 쿼리의 파티션 키**:
   - 이론적으로는 파티션 키를 포함하는 것이 좋지만, 실제 성능 차이는 데이터 분포에 따라 달라짐
   - 본 테스트에서는 데이터가 특정 기간(2024년)에 집중되어 있어 성능 차이가 미미함 (약 1%)
   - 데이터가 여러 연도에 고르게 분포되어 있다면 파티션 키 포함 시 더 큰 성능 향상이 예상됨

4. **권장사항**:
   - 시계열 데이터는 RANGE 파티셔닝 적용 권장
   - 조회 쿼리에 파티션 키 (created_date) 포함 권장
   - 파티션 개수는 데이터 양과 조회 패턴에 맞게 조정 필요
   - JOIN 쿼리에서도 가능하면 파티션 키를 포함하여 파티션 프루닝 활용