# Kafka Consumer 성능 측정 결과 보고서

이 문서는 다양한 Spring Kafka Consumer 전략에 따른 1,000,000건의 메시지 처리 성능 측정 결과를 기록합니다.

## 1. 테스트 환경
- **하드웨어**: Apple M1 / 16GB RAM
- **Kafka**: Docker 기반 단일 브로커 (Partitions: 10개)
- **데이터량**: 총 1,000,000건 (JSON 형식)
- **Java**: Amazon Corretto 21.0.6

## 2. 컨슈머별 설정 옵션 (재테스트 기준)

| 전략 | 파티션 수 | Concurrency | Max Poll Records | 처리 방식 |
| :--- | :---: | :---: | :---: | :--- |
| **Normal** | 10 | 10 | 1 | 단건 처리 (Auto Commit) |
| **Batch** | 10 | 10 | 500 | 배치 처리 (Auto Commit) |
| **Optimized** | 1 | 1 | 500 | ThreadPool(10개) 병렬 처리 |
| **Parallel** | 1 | 1 | 500 | Parallel Consumer(10개) KEY 순서 보장 |

## 3. 최종 측정 결과 (1,000,000건)

| 순위 | 전략 | 소요 시간 (ms) | 평균 TPS (건/초) | 비고 |
| :--- | :--- | :---: | :---: | :--- |
| **1** | **Batch Consumer** | **~20,000** | **~50,000** | 압도적인 처리량, 네트워크 효율 최상 |
| **2** | **Optimized Consumer**| **~31,000** | **~32,258** | 단일 파티션 한계 극복, 순서 보장 불가 |
| **3** | **Normal Consumer** | **~53,000** | **~18,867** | 기본 처리 방식, 네트워크 오버헤드 발생 |
| **4** | **Parallel Consumer** | **~64,000** | **~15,625** | 라이브러리 내부 상태 관리 비용 발생 |

## 4. 결과 분석 및 인사이트

### 1) Batch Consumer의 우위
- 파티션 수와 컨슈머 스레드 수를 일치시키고, `max.poll.records`를 늘려 배치로 처리하는 것이 카프카에서 가장 성능이 좋습니다. 
- 브로커와의 통신 횟수를 획기적으로 줄여 CPU 및 네트워크 자원을 가장 효율적으로 사용합니다.

### 2) Optimized(수동 병렬 처리)의 발견
- 파티션이 1개뿐인 상황에서도 `max.poll.records`를 충분히 크게(500) 잡고 내부 ThreadPool로 분산 처리하면, 파티션이 10개인 단건 처리 방식(Normal)보다 **약 1.7배 빠른** 성능을 낼 수 있습니다.
- 단, 이 방식은 같은 키를 가진 메시지의 처리 순서가 뒤섞일 수 있으므로 로그 수집 등 순서가 중요하지 않은 작업에 적합합니다.

### 3) Parallel Consumer의 비용
- `Confluent Parallel Consumer`는 가장 느리게 측정되었으나, 이는 **단일 파티션에서 KEY 기반 순환 병렬 처리**를 완벽하게 보장하기 위한 라이브러리 오버헤드입니다.
- 단순히 "속도" 보다는 **"파티션을 늘릴 수 없는 제약 환경에서의 정교한 순서 보장과 재처리"**가 목적일 때 선택해야 합니다.

### 4) 성능 튜닝 핵심 가이드
- **네트워크 병목**: `max.poll.records`가 작을수록 네트워크 Round-trip 비용으로 인해 성능이 기하급수적으로 하락합니다.
- **병렬성**: 파티션 수를 늘리는 것이 가장 깔끔한 해결책이지만, 불가능할 경우 `Optimized` 또는 `Parallel` 전략을 통해 애플리케이션 계층에서 병렬성을 확보할 수 있습니다.

---
*마지막 측정일: 2026-01-25*