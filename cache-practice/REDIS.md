# 레디스

Redis는 key - value를 사용하는 in memory 데이터 저장소입니다.   
일반적인 RDB 같은 경우엔 `select * from table where ~` 과 같은 DML을 이용하여 데이터를 조회합니다.   
하지만 key - value는 명확히 key만을 지정해서 데이터를 조회하기 때문에 어떤 특별한 조건 없이 데이터를 가져올 수 있습니다.   
그리고 disk에 데이터를 저장하는 RDB와 달리 인 메모리 기반이기 때문에 처리 속도가 빠르며, 원한다면 영속성을 보장하는 모드를 사용할 수 있습니다.

## 레디스 동작 원리
레디스는 싱글 스레드 이벤트 루프 방식으로 요청을 처리합니다.
1. client로부터 요청이 들어온다.
2. redis 서버는 멀티 스레드로 client의 요청을 받고, 소켓을 생성한다.   
3. 이벤트 루프(싱글 스레드)는 요청을 전달받고, 소켓을 생성한 스레드에게 즉시 응답한다.
4. 이후 워커 큐에서는 이벤트 루프에 적재된 요청을 처리하고, 소켓에 결과를 쓰기 작업을 한다. 

앞단에서 클라이언트와 커넥션을 맺고, 소켓을 생성하는 부분에서는 multi thread로 동작하여 많은 양의 요청을 받을 수 있습니다.   
그리고 뒷단의 워커는 싱글 스레드로 동작하기 때문에 컨텍스트 스위칭, 데드락이 발생하지 않고 데이터를 빠르게 처리할 수 있는 장점이 있습니다.   
다만, 싱글 스레드기 때문에 오버헤드가 큰 가령 전체 데이터 조회와 같은 요청은 처리하는 동안 다른 처리를 블로킹시킬 수 있습니다.

## 레디스 동시성 문제
레디스는 하나의 한 요청을 원자적으로 수행하는 특성을 가지고 있습니다.   
때문에 애플리케이션의 비즈니스 로직 상으로 RDB -> Redis -> RDB -> Redis의 흐름으로 간다면, MySQL은 트랜잭션으로 여러 DML이 하나의 묶음으로 처리되겠지만 redis 관점에선 단순 하나의 요청이 들어온 꼴입니다.   
따라서 한 비즈니스 흐름안에서 redis의 결과가 상이해질 수 있고, 롤백 상황에서 데이터의 정합성이 틀려질 수 있습니다.      
이를 방지하기 위해 redis에서의 트랜잭션을 구현할 수 있다.

### MULTI / EXEC
RDB에서 제공하는 트랜잭션과 달리 명령어를 일괄적으로 순차 처리하는 방식입니다.  

```kotlin
MULTI
SET key1 "value1"
SET key2 "value2"
EXEC
```
명령어를 한 데 모아서 처리하여 순차 실행할 수 있습니다.   
하지만 중간 명령어에서 에러가 발생하면, EXEC까지 도달하지 못했으므로 명령어가 실행되지 않고, 에러를 반환합니다.   

### 트랜잭션, WATCH
WATCH 명령어는 트랜잭션 실행 전 지정한 키의 변경을 감지할 수 잇습니다.   
즉, MULTI ~ EXEC 안에 존재하는 key가 다른 클라이언트의 요청에 의해 변경되었다면, 트랜잭션 실행 전 키의 변경을 감지하고 낙관적 락으로 인해 EXEC는 실패하게 됩니다.  

```kotlin
WATCH balance
MULTI
DECR balance
EXEC
```

### 루아 스크립트
redis는 lua 언어로 스크립트를 작성하고, 이를 원자적으로 실행할 수 있습니다.  
이를 이용하여 redis의 명령어들을 스크립트에 모아 원자적으로 처리하므로 트랜잭션 처리가 가능하게 합니다.   
하지만 이 명령어의 집합이 길어질수록 싱글 스레드 워커로 명령어를 처리하므로 다른 명령어들이 블로킹될 수 있습니다.

```kotlin
redis> eval "local sum = ARGV[1] + ARGV[2]  local res = redis.call('SET', KEYS[1], sum) return res"
```

### Spring에서 레디스 트랜잭션 적용

```kotlin
@Configuration
@EnableTransactionManagement                                 
class RedisTxContextConfiguration {

  @Bean
  fun redisTemplate():  StringRedisTemplate {
    val template = StringRedisTemplate(redisConnectionFactory())
    template.setEnableTransactionSupport(true)              
    return template
  }

  @Bean
  fun transactionManager(): PlatformTransactionManager {
    return DataSourceTransactionManager()
  }
}
```

## 레디스 자료형
https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85Collection-%EC%A2%85%EB%A5%98-%EC%A0%95%EB%A6%AC#redis_-_hashes

### Strings
value에 문자, 숫자를 저장할 수 있습니다.   
최대 512MB의 크기를 저장할 수 있으며, 원자적으로 증감 연산을 수행할 수 있습니다.   

### Lists
중복이 허용되는 링크드 리스트를 value에 저장합니다.  
특정 index의 값을 조회할 경우 순차적으로 탐색을 해야하기 떄문에 O(N)의 속도를 가지고, 마찬가지로 중간 노드를 추가하거나 삭제할 경우에도 같은 시간복잡도를 가집니다.

### Sets
중복이 허용되지 않은 리스트를 value에 저장합니다.   
단, Lists와 달리 정렬이 불가한 자료구조입니다.   

### Sorted Sets
Sets의 자료구조에 score(정렬 값)라는 필드가 추가되어 정렬이 가능하게 된 자료구조입니다.   
score는 중복 가능하며, 중복이 될 경우 글자순으로 저장됩니다.   

### Hashes
해시 key - value를 가진 자료형이며, key 하위에 subkey를 추가한 자료구조입니다. 

## 레디스 용도 - 데이터 캐싱
레디스는 in memory로 데이터를 저장하고, 조회할 수 있습니다.   
메모리이기 때문에 disk보다 고성능으로 데이터를 처리가능하지만, 영구하게 저장이 되지 않는다는 특징을 가지고 있습니다.   
Time To Live마다 초기화되므로 데이터를 새로 갱신해준다던지, 원천 저장소가 업데이트될 때 어떤 전략으로 캐시 데이터를 업데이트할지 등의 고려가 필요합니다.   

이를 이용해서 원천 저장소로 가는 트래픽을 캐시로 돌릴 수 있기 때문에 원천 저장소에 대한 부하를 줄여줄 수 있고, 빠르게 데이터를 서빙할 수 있다는 장점이 있기 때문에 상당히 많은 곳에서 사용됩니다.   

## 레디스 용도 - 분산 락
OLTP 환경에서는 여러 클라이언트가 하나의 데이터를 대상으로 끊임없이 쓰기 요청이 들어올 수 있습니다.   
동시에 접근하기 때문에 2개의 요청이 1개의 명령어로 처리될 수 있고, 하나의 비즈니스 흐름에서 조회한 데이터가 계속해서 변경될 수 있는 위험이 존재합니다.   
언어 레벨에서 지원하는 동시성 제어 기법으로 이를 방지할 수 있으나, 대부분의 상용 서비스들은 하나의 애플리케이션을 멀티 인스턴스로 사용하기 때문에 쉽지 않습니다.   
때문에 글로벌하게 다른 요청을 차단할 수 있도록 redis에서는 분산락 기법을 제공합니다.   

### RedLock
레드락은 N개의 redis 노드들을 대상으로 M개(Quorum)의 노드들로부터 잠금을 획득할 경우 분산락을 획득하는 기법입니다.   

1. ms 단위로 현재 시간을 가져온다.
2. N개의 인스턴스에 순차적으로 락을 획득하고, 락 설정 시 전체 락 자동 해제 시간(lease) > 락 타임아웃으로 락을 획득한다.
   * 락 타임아웃을 낮게 가져가는 이유는 특정 인스턴스가 처리 불가 상태일 수 있기 때문이다.
3. 이렇게 N개의 인스턴스에게 락을 획득하고, 잠금 유효 시간 > 경과 시간 그리고 Quorum을 넘겼다면 분산락을 획득했다고 간주한다.
4. 분산락의 잠금 유효 시간(wait)은 3번에서 계산된 시간이다.
5. 분산락을 획득하지 못했다면, N개의 인스턴스에서 걸어둔 잠금을 해제한다.

## 레디스 용도 - 메시지 큐
레디스는 pub / sub 구조의 시스템을 제공합니다.   
메시지를 특정 채널로 퍼블리싱하고, 특정 채널을 구독중인 구독자들은 메시지를 수신받아 비즈니스를 처리할 수 있습니다.   
이러한 특징 덕분에 채팅, 알림 등 다양한 곳에서 활용할 수 있습니다.

하지만 redis의 pub / sub은 kafka, rabbitmq 등 다른 메시지 큐들과는 달리 메시지를 영구하게 보관하지 않고, 채널로 메시지를 발행하면 바로 소실됩니다.    
그리고 구독자들이 메시지를 수신했는지 (ack)의 과정 없이 메시지를 발행하기만 하는 구조입니다.   
이렇기 때문에 비동기 메시지에 대한 신뢰성 보장(메시지 유실)이 필요하거나, 리플레이가 필요(메시지 재발행)하거나 등과 같은 비즈니스에는 적용할 수 없습니다.     
