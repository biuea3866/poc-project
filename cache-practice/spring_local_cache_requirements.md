## 스프링 로컬 캐시 예제 생성 요구사항

**목표:** 효과적인 로컬 캐싱 전략을 시연하는 스프링 부트 애플리케이션을 생성합니다. 이 예제는 스프링의 캐싱 추상화를 선택된 로컬 캐시 공급자와 함께 사용하여 일반적인 캐싱 문제를 해결하는 방법을 보여주어야 합니다.

**핵심 요구사항:**

1.  **애플리케이션 설정:**
    *   스프링 부트 애플리케이션 (Kotlin 선호, 하지만 선택된 캐시 라이브러리에 더 적합하다면 Java도 허용).
    *   스프링의 캐싱 메커니즘 활성화 (`@EnableCaching`).

2.  **데이터 모델:**
    *   `id`, `name`, `price` 필드를 가진 간단한 `Product` 데이터 클래스/엔티티를 정의합니다.

3.  **서비스 계층 (`ProductService`):**
    *   데이터 검색 및 조작을 시뮬레이션하는 `ProductService`를 구현합니다 (예: 데이터베이스 또는 간단한 인메모리 맵).
    *   **`getProductById(id: Long)`:**
        *   `@Cacheable`을 사용하여 캐싱을 구현합니다.
        *   "Look Aside" 읽기 전략을 시연합니다.
        *   캐시 적중 및 누락을 명확하게 보여주는 로깅을 포함합니다.
        *   존재하지 않는 제품에 대해 빈 값을 캐싱하여 "캐시 관통(Cache Penetration)"을 해결합니다 (Optional 래핑 또는 센티널 객체 사용).
    *   **`createProduct(product: Product)`:**
        *   기본 데이터 저장소에 새 제품을 추가합니다.
        *   캐시가 적절하게 업데이트되거나 제거되도록 합니다 (예: `@CachePut` 또는 `@CacheEvict`).
    *   **`updateProduct(id: Long, product: Product)`:**
        *   기본 데이터 저장소에서 제품을 업데이트합니다.
        *   업데이트된 제품에 대한 캐시 항목이 새로 고쳐지도록 합니다 (`@CachePut`).
    *   **`deleteProduct(id: Long)`:**
        *   기본 데이터 저장소에서 제품을 제거합니다.
        *   해당 캐시 항목이 제거되도록 합니다 (`@CacheEvict`).

4.  **로컬 캐시 공급자:**
    *   로컬 캐시 공급자를 선택합니다 (예: Caffeine, Guava 또는 간단한 `ConcurrentHashMap`을 통한 기본 시연). **Caffeine은 고급 제거 정책(Window TinyLfu)으로 인해 권장됩니다.**
    *   선택한 캐시 공급자를 구성합니다 (예: 캐시 이름, 제거 정책, TTL).
    *   **Caffeine 및 EHCache 성능 비교:** 가능하면 Caffeine과 EHCache를 모두 사용하여 예제를 구현하거나, 두 라이브러리 간의 성능 특성 및 설정 차이를 설명합니다.

5.  **캐싱 운영 방식 조합 예제:**
    *   Spring 표준 어노테이션을 사용한 읽기/쓰기 전략 조합을 시연합니다:
        *   **Look Aside (읽기) + Write Through (쓰기)**: `@Cacheable` + `@CachePut` 조합
        *   **Look Aside (읽기) + Invalidate (쓰기)**: `@Cacheable` + `@CacheEvict` 조합
    *   각 조합의 장단점과 사용 시나리오를 설명합니다.

6.  **캐싱 문제 해결:**
    *   **캐시 스템피드 (Cache Stampede):** `getProductById`에 대한 캐시 스템피드를 완화하는 메커니즘을 시연합니다. 다음을 포함할 수 있습니다.
        *   잠금 메커니즘 (예: `synchronized` 블록 또는 Caffeine의 `get(key, mappingFunction)`)을 사용하여 하나의 스레드만 캐시를 다시 로드하도록 합니다.
        *   (선택 사항) 핫키 만료 시나리오 (특정 키가 만료될 때 대량의 동시 요청 발생)도 동일한 메커니즘으로 해결됨을 설명합니다.
    *   **캐시 관통 (Cache Penetration):** `getProductById`가 존재하지 않는 ID에 대해 빈 값(Optional.empty() 또는 센티널 객체)을 캐싱하여 누락된 데이터에 대한 반복적인 데이터베이스 조회를 방지하도록 합니다.

7.  **검증:**
    *   다음과 같은 단위 또는 통합 테스트를 포함합니다.
        *   `getProductById`에 대한 캐시 적중/누락 동작을 확인합니다.
        *   `create`, `update`, `delete` 작업이 캐시와 올바르게 상호 작용하는지 확인합니다 (예: 항목 새로 고침 또는 제거).
        *   캐시 스템피드 처리를 시연합니다 (예: 동시 요청 시뮬레이션을 통해).
    *   **성능 비교 및 모니터링:** 캐싱 솔루션의 성능을 비교하기 위한 기본적인 메트릭 (예: 응답 시간, DB 호출 횟수)을 측정하고, 이를 모니터링할 수 있는 간단한 방법을 제시합니다 (예: Actuator, Prometheus/Grafana 연동 설명).

8.  **코드 구조 및 주석:**
    *   코드를 적절한 패키지 (예: `model`, `service`, `config`)로 구성합니다.
    *   캐싱 로직, 전략 및 문제 완화에 대한 명확한 주석을 추가합니다.

**예상 출력:**
실행 준비가 된 소스 코드 파일 (`.kt` 또는 `.java`), 구성 파일 및 테스트 파일을 포함하는 완전한 스프링 부트 프로젝트 구조.
