# 로컬 캐시 조합 예제

## Look Aside + Write Around
* 읽기: 애플리케이션이 캐시에서 데이터를 읽고, 존재하지 않으면 데이터베이스에서 조회 (캐시 미스 시 DB에서 값을 읽어와 캐시 업데이트)
* 쓰기: 캐시에 저장 하지 않고, DB에만 저장

애플리케이션이 DB, 캐시에 접근하는 모든 로직을 담당하여 데이터를 조회합니다.  
캐시 미스 시에만 캐시를 업데이트하기 때문에 실시간 성이 다소 떨어지고, 캐시 스템피드 현상이 발생할 수 있습니다.   
장점으로는 쓰기 시 바로 캐시에 저장하지 않기 때문에 애플리케이션에서 리소스가 덜 쓰입니다.

## Read Through + Write Around
* 읽기: 애플리케이션이 캐시에서 데이터를 읽고, 존재하지 않으면 캐시 서버가 데이터베이스에서 조회 (캐시 미스 시 캐시 서버가 DB에서 값을 읽어와 캐시 업데이트)
* 쓰기: 캐시에 저장 하지 않고, DB에만 저장

1번 예제와의 차이는 캐시를 업데이트하는 주체가 애플리케이션 서버냐, 캐시 서버냐의 차이입니다.  
Read Through의 경우 데이터 조회 시 접근하는 모든 책임이 캐시 서버에 있으므로 리소스 관점에서 덜쓴다는 차이를 보입니다.

하지만 redis가 MySQL과 연결되어 로직을 가진다는 것은 의문이므로 사실 상 Spring의 경우 캐시 어노테이션을 이용하여 로직을 구현하거나, 별도의 조회용 API 서버(MySQL, Redis와 연결된)를 띄워서 이 API를 호출하는 형식이 아닌가 생각이 듭니다. 

## Read Through + Write Through
* 읽기: 애플리케이션이 캐시에서 데이터를 읽고, 존재하지 않으면 캐시 서버가 데이터베이스에서 조회 (캐시 미스 시 캐시 서버가 DB에서 값을 읽어와 캐시 업데이트)
* 쓰기: 캐시와 DB에 데이터를 저장합니다.

앞선 예제들보다 실시간 성의 캐싱 업데이트가 뛰어난 패턴입니다.   
쓰기 시 실시간으로 캐시를 업데이트하고, 조회 시 캐시 미스가 날 경우 캐시를 업데이트하므로 실시간 성의 성격이 뛰어납니다.  
다만, 쓰기 API의 호출량이 많으면 많을수록 2가지의 일을 처리해야하므로 부하가 상대적으로 많이 발생합니다.   

