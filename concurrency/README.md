# 동시성 처리
동시성 문제는 여러 스레드가 공유하는 데이터에 동시 접근 시 데이터 정합성이 깨지거나 시스템 안정성이 저하됨을 의미합니다.

> 싱글 스레드는 괜찮은가? 

멀티 스레드가 동시성에서 문제가 되는 이유는 하나의 인스턴스에 대해 여러 스레드가 스위칭하며, 접근하는 상황에서 문제가 됩니다.   
각 스레드들은 인스턴스에 접근하여 내부 상태를 업데이트하게 되는데, 서로의 순서가 없다보니 동시에 상태를 업데이트할 경우 동작 1개가 무시되며, 문제 상황이 발생합니다.   
하지만 싱글 스레드는 혼자서 모든 요청을 처리하기 떄문에 순차적으로 모든 요청을 처리하고, 컨텍스트 스위칭이 없기 때문에 동시성 문제가 발생하지 않습니다.

## 자바에서의 동시성 처리 방법
### Mutex (상호배제)
멀티 스레드 환경에서 코드 블록 접근 시 접근을 제어하는 방법입니다.  
하나의 인스턴스나 리소스에 하나의 스레드만 접근하게 함으로써 동기화 문제를 해결합니다.   
즉, 하나의 스레드가 lock을 걸고 unlock을 수행하기 전까지는 다른 스레드가 접근하지 못함을 의미합니다.

### 모니터
스레드는 모니터를 소유하는데 이 모니터는 상호배제와 협력을 가지도록 하는 동기화 메커니즘입니다.   
협력은 Conditional Variable(조건 변수)를 가지게 되는데 이를 이용하여 스레드의 락을 언제까지 대기시키고, 스레드를 실행시킬지를 결정합니다.  

* EntrySet
  * Lock을 획득하기 위해(코드를 실행하기 위해) 대기중인 스레드들을 모아놓은 자료구조
  * Lock이 반납되면, 이 자료구조 안에 있는 스레드가 Lock을 획득
* WaitSet
  * Lock을 획득했으나 특정 조건(비즈니스 조건)을 만족하지 못한 스레드를 대기시키고, 락을 푼 뒤 대기하는 자료구조
    * 특정 조건을 만족하지 못했으니 해당 스레드는 비즈니스를 수행하지 못함
  * 다른 스레드가 특정 조건을 만족시켜주고, notify or notifyAll로 WaitSet의 스레드에게 조건을 만족했음을 알림

### 스핀락
스핀락은 무한 루프를 돌며, 계속해서 락을 획득할 수 있는지 확인하는 방법입니다.   
Mutex와 같은 락은 다른 스레드를 블록시켜버리지만, 스핀락은 모든 스레드들이 무한 루프를 돌며 자신이 락을 획득할 수 있는지 확인합니다.   
때문에 엄청 오래걸리는 IO 작업을 대상으로 락 획득이 수행된다면, 모든 스레드가 무한 루프를 돌기 때문에 cpu가 지속적으로 사용되는 성능적인 문제를 줄 수 있습니다.  

### Synchronized
자바의 synchronized 키워드는 함수, 블록 단위로 여러 스레드가 동시 접근 시 하나의 스레드만 허용하고, 이 외의 스레드들은 접근을 막아 동시성 문제를 해결하는 장치입니다.   
데이터를 동기화한다는 측면에서 좋아보이는 기법이나 접근 제어가 되는 함수가 오랫동안 IO 작업을 하는 함수라면, 나머지 스레드들 또한 블로킹이 되기 때문에 심각한 성능 저하를 초래할 수 있습니다.

### ReentrantLock
ReentrantLock도 Synchronized와 마찬가지로 여러 스레드가 접근하는 것을 제어하는 방법 중 하나입니다.   
다만 Synchronized가 함수 레벨에서 동기화를 제공했다면, ReentrantLock는 유연하게 동기화를 하고자하는 블록을 지정하여 처리할 수 있습니다.   
그리고 `AbstractQueuedSynchronizer`를 이용하여 스레드에게 순서를 부여하고, FairSync를 구현합니다.

### CAS
자바의 Synchronized는 스레드들을 블로킹하여 동시성 문제를 해결하기 위한 장치입니다.   
이는 시스템의 성능 저하 문제를 야기하게 되는데 이 문제를 해결하기 위한 방법이 atomic 변수입니다.   
atomic 변수는 Compare And Swap알고리즘을 이용하여 non-blocking하게 동작하면서 원자성을 보장합니다.   
1. 함수 인자로 기존 값, 변경할 값을 전달
2. 기존 값이 현재 메모리에 있는 값과 같다면 변경할 값을 메모리에 반영하고, true 반환
3. 기존 값이 현재 메모리에 있는 값과 같지 않다면, false 반환
   * 같지 않다는 것은 이미 다른 스레드가 값을 변경하였음을 의미

Synchronized는 아예 모든 접근을 막아버리는 반면 CAS는 막지 않고, 계산으로 원자성을 보장함으로 성능적으로 더 우수합니다. 

```kotlin
// count 증분을 100만번 했을 때 속도 차이 
synchronizedMeasureTime: 319.140916ms vs casMeasureTime: 267.320792ms
```

### Semaphore
Mutex가 하나의 스레드가 접근되었을 때 다른 스레드들을 전부 차단했다면, Semaphore는 n개의 스레드까지는 접근 가능하도록 허용하는 기법입니다.   
즉, 특정 갯수까지는 동시성 문제 해결이 보장된다면 특정 갯수까지는 스레드 접근을 허용하여 성능을 높일 수 있습니다.
```kotlin
pool-1-thread-2 - current view count: 2
pool-1-thread-1 - current view count: 1
pool-1-thread-3 - current view count: 3
pool-1-thread-2 - current view count: 4
pool-1-thread-1 - current view count: 5
pool-1-thread-2 - current view count: 7
pool-1-thread-3 - current view count: 6
pool-1-thread-3 - current view count: 10
pool-1-thread-2 - current view count: 9
pool-1-thread-1 - current view count: 8
```

## 인프라에서의 동시성 처리 방법
### MySQL
### Redis